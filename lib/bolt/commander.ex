defmodule Bolt.Commander do
  @moduledoc """
  The brain of bolt. This checks whether a message is a valid command,
  and if so, applies predicates and then invokes the defined callback
  for the given command.

  Commands can be defined in `Bolt.Commander.Server` in a mapping of in the form
    command_name -> module | map
  If the command name is mapped to a module, the commander will invoke that command
  (which must implement the `Bolt.Command` behaviour directly.
  Otherwise, if the command name is mapped to a map, the commander will assume it
  is a command group and perform the same procedure as above, however, supporting
  an optional `:default` map key pointing to a module (implementing `Bolt.Command`)
  that will be invoked if no subcommand was found.
  """

  alias Bolt.Commander.Server
  alias Nostrum.Api
  alias Nostrum.Struct.{Embed, Message}

  @prefix Application.fetch_env!(:bolt, :prefix)

  @spec find_failing_predicate(
          Message.t(),
          (Message.t() ->
             {:ok, Message.t()} | {:error, Embed.t()})
        ) :: nil | {:error, Embed.t()}
  def find_failing_predicate(msg, predicates) do
    predicates
    |> Enum.map(& &1.(msg))
    |> Enum.find(&match?({:error, _embed}, &1))
  end

  @spec parse_args(Module.t(), [String.t()]) :: [String.t()] | any()
  defp parse_args(command_module, args) do
    if Kernel.function_exported?(command_module, :parse_args, 1) do
      command_module.parse_args(args)
    else
      args
    end
  end

  @spec invoke(Module.t(), Message.t(), [String.t()]) :: any()
  defp invoke(command_module, msg, args) do
    if Kernel.function_exported?(command_module, :predicates, 0) do
      case find_failing_predicate(msg, command_module.predicates()) do
        nil ->
          command_module.command(msg, parse_args(command_module, args))

        {:error, reason} ->
          # a predicate failed. show the response generated by it
          {:ok, _msg} = Api.create_message(msg.channel_id, reason)
      end
    else
      command_module.command(msg, parse_args(command_module, args))
    end
  end

  @spec handle_command(Map.t() | Module.t(), Message.t(), [String.t()]) ::
          :ignored | {:ok, Message.t()} | any()
  defp handle_command(command_map, msg, [subcommand | args]) when is_map(command_map) do
    case Map.fetch(command_map, subcommand) do
      {:ok, subcommand_module} ->
        invoke(subcommand_module, msg, args)

      :error ->
        if Map.has_key?(command_map, :default) do
          invoke(command_map.default, msg, args)
        else
          subcommand_string =
            command_map |> Map.keys() |> Stream.map(&"`#{&1}`") |> Enum.join(", ")

          response = "ğŸš« unknown subcommand, known subcommands: #{subcommand_string}"
          {:ok, _msg} = Api.create_message(msg.channel_id, response)
        end
    end
  end

  defp handle_command(command_module, msg, args) do
    invoke(command_module, msg, args)
  end

  @spec try_split(String.t()) :: [String.t()]
  def try_split(content) do
    OptionParser.split(content)
  rescue
    _ in RuntimeError -> String.split(content)
  end

  @doc """
  Handle a message sent over the gateway.
  If the message starts with the prefix and
  contains a valid command, the arguments
  are parsed accordingly and passed to
  the command along with the message.
  Otherwise, the message is ignored.
  """
  @spec handle_message(Message.t()) :: :ignored | {:ok, Message.t()} | any()
  def handle_message(msg) do
    with [@prefix <> command_name | args] <- try_split(msg.content),
         cmd_module_or_map when cmd_module_or_map != nil <- Server.lookup(command_name) do
      handle_command(cmd_module_or_map, msg, args)
    else
      _err -> :ignored
    end
  end
end
