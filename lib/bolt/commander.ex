defmodule Bolt.Commander do
  alias Bolt.Cogs
  alias Bolt.Commander.Parsers
  alias Bolt.Commander.Checks
  alias Nostrum.Api

  @commands %{
    "echo" => %{
      callback: &Cogs.Echo.command/2,
      parser: &Parsers.passthrough/1,
      help: "Echo the given command."
    },
    "guildinfo" => %{
      callback: &Cogs.GuildInfo.command/2,
      parser: &Parsers.passthrough/1,
      help: "Show information about the current Guild.",
      predicates: [&Checks.guild_only/1]
    },
    "memberinfo" => %{
      callback: &Cogs.MemberInfo.command/2,
      parser: &Parsers.passthrough/1,
      help: "Show information about the mentioned member, or yourself.",
      predicates: [&Checks.guild_only/1]
    },
    "roleinfo" => %{
      callback: &Cogs.RoleInfo.command/2,
      parser: &Parsers.passthrough/1,
      help: "Show information about the given role.",
      predicates: [&Checks.guild_only/1]
    },
    "roles" => %{
      callback: &Cogs.Roles.command/2,
      parser: &Parsers.passthrough/1,
      help: "Show all roles on the guild the command is invoked on.",
      predicates: [&Checks.guild_only/1]
    }
  }

  @aliases %{
    "ginfo" => "guildinfo",
    "guild" => "guildinfo",
    "minfo" => "memberinfo",
    "member" => "memberinfo",
    "rinfo" => "roleinfo",
    "role" => "roleinfo"
  }

  defp find_failing_predicate(_msg, predicates) when predicates == [] do
    nil
  end

  defp find_failing_predicate(msg, [predicate | rest]) do
    case predicate.(msg) do
      {:ok, _msg} -> find_failing_predicate(msg, rest)
      {:error, embed} -> embed
    end
  end

  @spec invoke(Map.t(), Nostrum.Structs.Message.t(), [String.t()]) :: no_return()
  defp invoke(%{callback: callback, parser: parser} = command, msg, args) do
    case Map.get(command, :predicates, []) do
      # no predicates -> invoke command directly
      [] ->
        # TODO: Instead of splitting the entire message content,
        #       only split off the actual command, since that is
        #       not of interest to the command handler.
        callback.(msg, parser.(Enum.join(args, " ")))

      # non-empty predicate list -> ensure all of them pass
      predicates ->
        failed = find_failing_predicate(msg, predicates)

        case failed do
          nil ->
            # all predicates passed. invoke the command
            callback.(msg, parser.(Enum.join(args, " ")))

          embed ->
            # a predicate failed. show the response generated by it
            {:ok, _msg} = Api.create_message(msg.channel_id, embed: embed)
        end
    end
  end

  @doc """
  Handle a message sent over the gateway.
  If the message starts with the prefix and
  contains a valid command, the arguments
  are parsed accordingly and passed to
  the command along with the message.
  Otherwise, the message is ignored.
  """
  @spec handle_message(Nostrum.Struct.Message.t()) :: no_return
  def handle_message(msg) do
    case String.split(msg.content) do
      ["." <> command_name | args] ->
        case Map.get(@commands, command_name) do
          nil ->
            case Map.get(@aliases, command_name) do
              nil ->
                :ignored

              command_alias ->
                Map.get(@commands, command_alias)
                |> invoke(msg, args)
            end

          command ->
            invoke(command, msg, args)
        end

      _ ->
        :ignored
    end
  end
end
